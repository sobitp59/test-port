<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="style.css">
    <link rel="icon" type="image/png" sizes="96x96" href="favicon/favicon-96x96.png">

    <title>javascript : behind the scene | sobit prasad</title>
</head>
<body>
    <div class="container">
        <!-- Navbar -->
        <nav class="navbar">
            <div class="nav-brand"> SobitPrasad<span class="nav-brand-dot">.</span></div>
            <ul class="nav-list">
                <li class="list"><a class="link" href="index.html">home</a></li>
                <li class="list"><a class="link" href="projects.html">projects</a></li>
                <li class="list"><a class="link link-active" href="blogs.html">blogs</a></li>
            </ul>
        </nav>

        <!-- Header -->
        <header class="blog-header">
            <img class="blog-header-image" src="blogimages/javascript-hoisting.png" alt="header-img" srcset="">
            
            <div class="blog-intro">
                <h2 class="blog-header-intro">hoisting in javascript<span class="blog-header-dot">.</span></h2><br>
                <p class="sm">18 February, 2022 | Sobit Prasad</p>
                <!-- <article class="blog-blog"> -->
                   <div class="blog">
                       <!-- introduction -->
                        <h4 class="blog-topics">introduction<span class="blog-topics-dot">.</span></h4>
                        <p class="blog-detail">First of all, let's understand the term 'HOISTING'. Hoisting means lifting up. For example, when we hoist our flag or when a crane lifts something, it's hoisting(lifting up) that thing, Right? Now, before proceeding further, I will recommend you to read my previous blog, because both the blogs are connected to each other and it will help you to understand the concept of this blog very easily. But let's revise a few concepts from the previous blog.</p>
                        <p class="blog-detail">In the previous blog, we have understood that whenever we run our code an Execution Context is created and inside that context, we have two phases - Memory Creation Phase and Code Execution Phase. Memory Creation Phase runs first and allocates memory/space to all the variables and functions and after that Code Execution Phase runs and it assigns the actual values to its corresponding variables. But why I am saying here variables only, don't worry we will understand it later in this blog.</p>
                  
                        <!-- what happens when we run our JavaScript program? -->
                        <h4 class="blog-topics">variable hoisting in javascript<span class="blog-topics-dot">.</span></h4>
                        <p class="blog-detail">Now coming back again to the Memory Creation Phase. We know that when we run our code Javascript Engine scans the whole code and allocates memory to all the variables and functions. But, in the case of variables, it assigns with a default value of undefined in Memory Creation Phase only, even before the execution of our code. Now let's understand all these concepts with the help of examples.</p>    
                        <h5 class="blog-topics-ex">variable hoisting: using the keyword var<span class="blog-topics-dot">.</span></h5>
                        <ul class="blog-code-head">
                            <li class="blog-code-line"><span class="code-col">var</span> exOne = 'JS is fun';</li>
                            <li class="blog-code-line"><span class="code-col">console</span>.log(exOne);</li>
                            <li class="blog-code-line"><span class="code-col">// Output : JS is fun</span</li>
                        </ul>
                        <p class="blog-detail">What do you think, what will be the output? It's simple, Right? It will give <span class="blog-topics-dot blog-bold">JS is fun</span> in the console. Now let's move to the next program.</p>    
                        <ul class="blog-code-head">
                            <li class="blog-code-line"><span class="code-col">console</span>.log(exTwo);</li>
                            <li class="blog-code-line"><span class="code-col">var</span> exTwo = 'WebDev is fun';</li>
                            <li class="blog-code-line"><span class="code-col">console</span>.log(exTwo);</li>
                        </ul>
                        <p class="blog-detail">Now, what do you think, what will be the output? But before giving you the answer I want to remind you of something and that is 'Memory Creation Phase'. We know in Memory Creation Phase, Javascript Engine will allocate memory and the default value undefined to its variable before executing the program. So, let's find out the answer.</p>    
                        <p class="blog-detail">First, let's see the code above, here Javascript Engine will go to line 1 and find console.log(exTwo);. Now, it finds the variable exTwo but till now we haven't assigned any values to it and also trying to console log exTwo, Right? So, it will assign the default value i.e. undefined to exTwo. Now, JS Engine will move to line 2. Here, we are assigning <span class="blog-topics-dot blog-bold">WebDev is fun</span> to variable exTwo, so it will hold this value. Now, JS Engine will move to line 3, here we are again trying to console log variable exTwo. Now, it will print <span class="blog-topics-dot blog-bold">WebDev is fun</span>, because here we have assigned <span class="blog-topics-dot blog-bold">WebDev is fun</span> to variable exTwo. So our output will look something like this,</p>    
                        <ul class="blog-code-head">
                            <li class="blog-code-line"><span class="code-col">//Output :</span></li>
                            <li class="blog-code-line"><span class="code-col">//undefined</span></li>
                            <li class="blog-code-line"><span class="code-col">//WebDev is fun</span></li>
                        </ul>
                        <p class="blog-detail">In the above program, we tried to console log variable exTwo before declaring it. But, what if we try to console log the variable exTwo without declaring it. So, what do think, what will be the output when we run the below code?</p>    
                        <ul class="blog-code-head">
                            <li class="blog-code-line"><span class="code-col">console</span>.log(exTwo);</li>
                        </ul>
                        <p class="blog-detail">So, here also JS Engine will scan the whole program and it finds exTwo but there is no declaration for exTwo, so JS Engine will not assign any memory to it and throws an error.</p>    
                        <ul class="blog-code-head">
                            <li class="blog-code-line ex-line"><span class="code-col">Uncaught ReferenceError: exTwo is not defined</span></li>
                        </ul>
                        <p class="blog-detail blog-detail-ex">Difference between undefined and not defined. undefined: we will get undefined as an output when we try to access the variable before its being initialized or without initializing the variable. On the other hand, not defined is an error, we will face when we try to access the variable before declaring it.</p>    
                        <p class="blog-detail">Think it of as a stranger whom you don't know, will you let him/her in your house, No!, Right? Now let's understand hoisting through the 'let' and 'const' keywords.</p>    
                        
                        <h5 class="blog-topics-ex">variable hoisting: using the keywords let and const<span class="blog-topics-dot">.</span></h5>
                        <ul class="blog-code-head">
                            <li class="blog-code-line ex-line"><span class="code-col">console</span>.log(exThree);</li>
                            <li class="blog-code-line ex-line"><span class="code-col">let </span>exThree = 'Hi!';</li>
                        </ul>
                        <ul class="blog-code-head">
                            <li class="blog-code-line ex-line"><span class="code-col">console</span>.log(exFour);</li>
                            <li class="blog-code-line ex-line"><span class="code-col">const </span>exFour = 'Bye!';</li>
                        </ul>
                        <p class="blog-detail">When we declare variables using keywords let and const, it will work as same as the keyword var. But when we try to access the variable declared with keywords let and const before initializing it, it will throw an error.</p>    
                        <ul class="blog-code-head">
                            <li class="blog-code-line ex-line"><span class="code-col"> Uncaught ReferenceError: Cannot access 'exThree' before initialization
                            </span></li>
                        </ul>
                        <ul class="blog-code-head">
                            <li class="blog-code-line ex-line"><span class="code-col"> Uncaught ReferenceError: Cannot access 'exFour' before initialization
                            </span></li>
                        </ul>
                        <p class="blog-detail">But why do these happen? In the case of the keyword var, when we try to access the variable before initializing it we get undefined, but with keywords let and const we get an error. This happens because of the 'Temporal Dead Zone'. I will not cover this topic in this blog but don't worry we are going to play more with let and const and Temporal Dead Zone in the next blog. Now let's understand hoisting from the eyes of function.</p>    
                        
                        
                        <h4 class="blog-topics">functional hoisting in javascript<span class="blog-topics-dot">.</span></h4>
                        <ul class="blog-code-head">
                            <li class="blog-code-line">funcOne();</li>
                            <li class="blog-code-line"><span class="code-col">function</span> funcOne(){</li>
                                <li class="blog-code-line"><span class="code-col">console</span>.log('function one');</li>
                                <li class="blog-code-line">}</li>
                                <li class="blog-code-line"><span class="code-col">// Output : function one</span></li>
                        </ul>
                        <p class="blog-detail">What will be the output? Again, it's very simple, Right? We have used functions like it before so many times. But how does it possible to access a function even before declaring it. Have you remembered the last line of the second paragraph? So here is the answer, because in the case of functions, in Memory Creation Phase, JS Engine allocates the memory and the whole code inside that function as the value. Now when this function is invoked before or after the declaration of that function an Execution Context is created and in Memory Creation Phase inside this Execution Context, it will simply print the <span class="blog-topics-dot blog-bold">function one</span> in the console and after that, this Execution Context will be deleted and the control will be transferred to Global Execution Context. Now if don't understand yet, just simply copy and paste the below code and open the console, you will find your answer.</p>    
                        <ul class="blog-code-head">
                            <li class="blog-code-line">funcOne();</li>
                            <li class="blog-code-line"><span class="code-col">console</span>.log(funcOne);</li>
                            <li class="blog-code-line"><span class="code-col">function</span> funcOne(){</li>
                                <li class="blog-code-line"><span class="code-col">console</span>.log('I am function one');</li>
                                <li class="blog-code-line">}</li>
                            <li class="blog-code-line"><span class="code-col">console</span>.log(funcOne);</li>
                        </ul>
                        <p class="blog-detail">You will get output in the console as :</p>    
                        <ul class="blog-code-head">
                            <li class="blog-code-line">f <span class="code-col">function</span>(){</li>
                                <li class="blog-code-line"><span class="code-col">console</span>.log('I am function one');</li>
                            <li class="blog-code-line">}</li>
                            <li class="blog-code-line">f <span class="code-col">function</span>(){</li>
                                <li class="blog-code-line"><span class="code-col">console</span>.log('I am function one');</li>
                                <li class="blog-code-line">}</li>
                            </ul>
                        <p class="blog-detail">Now, you know how we are able to access the function even before declaring/initializing it. But, what if we write the same function using the fat arrow or anonymous function. So, let's find out our answer. We have our code below,</p>    
                        <ul class="blog-code-head">
                            <li class="blog-code-line"><span class="code-col">//using fat-arrow function</span></li>
                            <li class="blog-code-line"><span class="code-col">console</span>.log(funcOne);</li>
                            <li class="blog-code-line"><span class="code-col">var</span> funcOne = () => {</li>
                            <li class="blog-code-line"><span class="code-col">console</span>.log('I am function one');</li>
                                <li class="blog-code-line">}</li>
                            <li class="blog-code-line"><span class="code-col">console</span>.log(funcOne);</li>
                            <li class="blog-code-line">funcOne();</li>
                        </ul>
                        <ul class="blog-code-head">
                            <li class="blog-code-line"><span class="code-col">//using anonymous function</span></li>
                            <li class="blog-code-line"><span class="code-col">console</span>.log(funcOne);</li>
                            <li class="blog-code-line"><span class="code-col">var</span> funcOne = <span class="code-col">function</span>(){</li>
                            <li class="blog-code-line"><span class="code-col">console</span>.log('I am function one');</li>
                            <li class="blog-code-line">}</li>
                            <li class="blog-code-line"><span class="code-col">console</span>.log(funcOne);</li>
                            <li class="blog-code-line">funcOne();</li>
                        </ul>
                        <p class="blog-detail">And here I am asking for your answer again, so what will be your answer. Yes, you guessed it right, here funcOne will act as a variable in both cases and it will output in the console as :</p>    
                        <ul class="blog-code-head">
                            <li class="blog-code-line">undefined</li>
                            <li class="blog-code-line"><span class="code-col">console</span>.log(funcOne);</li>
                            <li class="blog-code-line">f (){</li>
                                <li class="blog-code-line"><span class="code-col">console</span>.log('I am function one');</li>
                                <li class="blog-code-line">}</li>
                                <li class="blog-code-line">I am function one</li>
                            </ul>
                        <p class="blog-detail">So, in both(using fat arrow and anonymous functions) the programs above, we have funcOne as a variable. So when JS Engine will scan these programs, it will allocate memory as well as the default value of undefined for line one. Now it will move to the next line and will assign the whole function to variable funcOne. In the second-last line, we are console logging the variable funcOne which holds the entire function in it, so it will print the whole code inside that function. Now, in the last line we are invoking funcOne which will now act as a function rather than a variable and again the whole cycle will repeat.</p>    
                        <p class="blog-detail">So, that's it guys in this blog. In the next blog, we will talk about the variable declared using keywords let and const, and also we will travel around the Temporal Dead Zone. Don't worry we will not die there. So, till then see you in the next blog.</p>    
         
































                    </div>
               <!-- </article>  -->
            </div>
        </header>

        <!-- Main -->
       

        <!-- Footer -->
        <footer class="footer">
            <h3 class="footer-head">connect with me<span>.</span></h3>
            <ul class="social">
                <li class="social-list"><a class="social-link" href="https://www.linkedin.com/in/sobit-prasad">linkedin<span>.</span></a></li>
                <li class="social-list"><a class="social-link" href="https://github.com/sobitp59">github<span>.</span></a></li>
                <li class="social-list"><a class="social-link" href="https://twitter.com/sobit_prasad">twitter<span>.</span></a></li>
            </ul>
        </footer>
    </div>
    
</body>
</html>